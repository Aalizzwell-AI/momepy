#!/usr/bin/env python
# -*- coding: utf-8 -*-

# intensity.py
# definitons of intensity characters

from tqdm import tqdm  # progress bar
import geopandas as gpd

'''
frequency:
    Calculate frequency (count) of objects in a given radius.

    Formula: count

    Attributes: objects = geoDataFrame with origins
                look_for = geoDataFrame with measured objects (could be the same)
                column_name = name of the column to save calculated values
                id_column = name of column where is stored unique id of each object.
                            If there is none, it could be generated by unique_id().
                radius = radius of buffer zone for calculation. Default is set to 400 (vicinity).
'''


def radius(gpd_df, cpt, radius):
    """
    https://stackoverflow.com/questions/44622233/rtree-count-points-in-the-neighbourhoods-within-each-point-of-another-set-of-po
    :param gpd_df: Geopandas dataframe in which to search for points
    :param cpt:    Point about which to search for neighbouring points
    :param radius: Radius about which to search for neighbours
    :return:       List of point indices around the central point, sorted by
                 distance in ascending order
    """
    # Spatial index
    sindex = gpd_df.sindex
    # Bounding box of rtree search (West, South, East, North)
    bbox = (cpt.x - radius, cpt.y - radius, cpt.x + radius, cpt.y + radius)
    # Potential neighbours
    good = []
    for n in sindex.intersection(bbox):
        dist = cpt.distance(gpd_df['geometry'][n])
        if dist < radius:
            good.append((dist, n))
    # Sort list in ascending order by `dist`, then `n`
    good.sort()
    # Return only the neighbour indices, sorted by distance in ascending order
    return [x[1] for x in good]


def frequency(objects, look_for, column_name, id_column='uID'):
    # define new column

    print('Calculating frequency...')

    objects_centroids = objects.copy()
    objects_centroids['geometry'] = objects_centroids.centroid

    look_for_centroids = look_for.copy()
    look_for_centroids['geometry'] = look_for_centroids.centroid

    objects_centroids[column_name] = None
    objects_centroids[column_name] = objects_centroids[column_name].astype('float')

    for index, row in tqdm(objects_centroids.iterrows(), total=objects_centroids.shape[0]):
        neighbours = radius(look_for_centroids, row['geometry'], 400)
        objects.loc[index, column_name] = len(neighbours)

    print('Frequency calculated.')
    # objects = objects.merge(objects_centroids[[id_column, column_name]], on=id_column, how='left')

'''
covered area ratio:
    Calculate covered area ratio of objects.

    Formula:  covering object area /covered object area
             (e.g. building area / cell area)

    Attributes: objects = geoDataFrame with objects being covered
                look_for = geoDataFrame with covering objects
                column_name = name of the column to save calculated values
                look_for_area_column = name of the column where is stored covering value
                id_column = name of column where is stored unique id of each object.
                            If there is none, it could be generated by unique_id().
'''


def covered_area_ratio(objects, look_for, column_name, area_column, look_for_area_column, id_column="uID"):

    print('Calculating covered area ratio...')

    print('Merging DataFrames...')
    look_for = look_for[[id_column, look_for_area_column]]  # keeping only necessary columns
    objects_merged = objects.merge(look_for, on='uID')  # merging dataframes together

    print('Calculating CAR...')

    # define new column
    objects_merged[column_name] = None
    objects_merged[column_name] = objects_merged[column_name].astype('float')

    # fill new column with the value of area, iterating over rows one by one
    for index, row in tqdm(objects_merged.iterrows(), total=objects_merged.shape[0]):
            objects_merged.loc[index, column_name] = row[look_for_area_column] / row[area_column]

    # transfer data from merged df to original df
    print('Merging data...')
    objects[column_name] = objects_merged[column_name]

    print('Covered area ratio calculated.')

'''
floor area ratio:
    Calculate floor area ratio of objects.

    Formula:  covering object floor area /covered object area
             (e.g. building floor area / cell area)

    Attributes: objects = geoDataFrame with objects being covered
                look_for = geoDataFrame with covering objects
                column_name = name of the column to save calculated values
                look_for_area_column = name of the column where is stored floor area value
                id_column = name of column where is stored unique id of each object.
                            If there is none, it could be generated by unique_id().
'''


def floor_area_ratio(objects, look_for, column_name, area_column, look_for_area_column, id_column="uID"):

    print('Calculating floor area ratio...')

    print('Merging DataFrames...')
    look_for = look_for[[id_column, look_for_area_column]]  # keeping only necessary columns
    objects_merged = objects.merge(look_for, on='uID')  # merging dataframes together

    print('Calculating FAR...')

    # define new column
    objects_merged[column_name] = None
    objects_merged[column_name] = objects_merged[column_name].astype('float')

    # fill new column with the value of area, iterating over rows one by one
    for index, row in tqdm(objects_merged.iterrows(), total=objects_merged.shape[0]):
            objects_merged.loc[index, column_name] = row[look_for_area_column] / row[area_column]

    # transfer data from merged df to original df
    print('Merging data...')
    objects[column_name] = objects_merged[column_name]

    print('Floor area ratio calculated.')

# objects.to_file("/Users/martin/Strathcloud/Personal Folders/Test data/Prague/p7_voro_single4.shp")
#
# objects = gpd.read_file("/Users/martin/Strathcloud/Personal Folders/Test data/Prague/p7_voro_single.shp")
# column_name = 'test'
# objects
# objects2.head
# objects['geometry'] = objects.centroid
# objects_centroids
