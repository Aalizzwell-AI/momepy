#!/usr/bin/env python
# -*- coding: utf-8 -*-

# intensity.py
# definitons of intensity characters

from tqdm import tqdm  # progress bar
import geopandas as gpd


def frequency(objects, look_for, column_name, id_column='uID'):
    """
    Calculate frequency (count) of objects in a given radius.

    Formula
    -------
    count

    Parameters
    ----------
    objects : GeoDataFrame
        geopandas gdf containing objects to analyse
    look_for : GeoDataFrame
        geopandas gdf with measured objects (could be the same as objects)
    column_name : str
        name of the column to save the values
    id_column : str
        name of the column with unique id

    Returns
    -------
    GeoDataFrame
        GeoDataFrame with new column [column_name] containing resulting values.

    Reference
    ---------

    """
    def radius(gpd_df, cpt, radius):
        """
        Get a list of indices of objects within radius.

        Parameters
        ----------
        gpd_df : GeoDataFrame
            geopandas gdf containing point objects to analyse
        cpt : shapely.Point
            shapely point representing the center of radius
        radius : float
            radius

        Returns
        -------
        list
            Return only the neighbour indices, sorted by distance in ascending order

        Reference
        ---------
        https://stackoverflow.com/questions/44622233/rtree-count-points-in-the-neighbourhoods-within-each-point-of-another-set-of-po

        """
        # Spatial index
        sindex = gpd_df.sindex
        # Bounding box of rtree search (West, South, East, North)
        bbox = (cpt.x - radius, cpt.y - radius, cpt.x + radius, cpt.y + radius)
        # Potential neighbours
        good = []
        for n in sindex.intersection(bbox):
            dist = cpt.distance(gpd_df['geometry'][n])
            if dist < radius:
                good.append((dist, n))
        # Sort list in ascending order by `dist`, then `n`
        good.sort()
        # Return only the neighbour indices, sorted by distance in ascending order
        return [x[1] for x in good]
    # define new column

    print('Calculating frequency...')

    objects_centroids = objects.copy()
    objects_centroids['geometry'] = objects_centroids.centroid

    look_for_centroids = look_for.copy()
    look_for_centroids['geometry'] = look_for_centroids.centroid

    objects_centroids[column_name] = None
    objects_centroids[column_name] = objects_centroids[column_name].astype('float')

    for index, row in tqdm(objects_centroids.iterrows(), total=objects_centroids.shape[0]):
        neighbours = radius(look_for_centroids, row['geometry'], 400)
        objects.loc[index, column_name] = len(neighbours)

    print('Frequency calculated.')
    return objects


def covered_area_ratio(objects, look_for, column_name, area_column, look_for_area_column, id_column="uID"):
    """
    Calculate covered area ratio of objects.

    Formula
    -------
    covering object area /covered object area
        (e.g. building area / cell area)

    Parameters
    ----------
    objects : GeoDataFrame
        geopandas gdf containing objects being covered (e.g. land unit)
    look_for : GeoDataFrame
        geopandas gdf with covering objects (e.g. building)
    column_name : str
        name of the column to save the values
    area_column : str
        name of the column of objects gdf where is stored area value
    look_for_area_column : str
        name of the column of look_for gdf where is stored area value
    id_column : str
        name of the column with unique id. If there is none, it could be generated by unique_id().

    Returns
    -------
    GeoDataFrame
        GeoDataFrame with new column [column_name] containing resulting values.

    Reference
    ---------

    """
    print('Calculating covered area ratio...')

    print('Merging DataFrames...')
    look_for = look_for[[id_column, look_for_area_column]]  # keeping only necessary columns
    objects_merged = objects.merge(look_for, on='uID')  # merging dataframes together

    print('Calculating CAR...')

    # define new column
    objects_merged[column_name] = None
    objects_merged[column_name] = objects_merged[column_name].astype('float')

    # fill new column with the value of area, iterating over rows one by one
    for index, row in tqdm(objects_merged.iterrows(), total=objects_merged.shape[0]):
            objects_merged.loc[index, column_name] = row[look_for_area_column] / row[area_column]

    # transfer data from merged df to original df
    print('Merging data...')
    objects[column_name] = objects_merged[column_name]

    print('Covered area ratio calculated.')
    return objects


def floor_area_ratio(objects, look_for, column_name, area_column, look_for_area_column, id_column="uID"):
    """
    Calculate floor area ratio of objects.

    Formula
    -------
    covering object floor area /covered object area
        (e.g. building floor area / cell area)

    Parameters
    ----------
    objects : GeoDataFrame
        geopandas gdf containing objects being covered (e.g. land unit)
    look_for : GeoDataFrame
        geopandas gdf with covering objects (e.g. building)
    column_name : str
        name of the column to save the values
    area_column : str
        name of the column of objects gdf where is stored area value
    look_for_area_column : str
        name of the column of look_for gdf where is stored floor area value
    id_column : str
        name of the column with unique id. If there is none, it could be generated by unique_id().

    Returns
    -------
    GeoDataFrame
        GeoDataFrame with new column [column_name] containing resulting values.

    Reference
    ---------

    """
    print('Calculating floor area ratio...')

    print('Merging DataFrames...')
    look_for = look_for[[id_column, look_for_area_column]]  # keeping only necessary columns
    objects_merged = objects.merge(look_for, on='uID')  # merging dataframes together

    print('Calculating FAR...')

    # define new column
    objects_merged[column_name] = None
    objects_merged[column_name] = objects_merged[column_name].astype('float')

    # fill new column with the value of area, iterating over rows one by one
    for index, row in tqdm(objects_merged.iterrows(), total=objects_merged.shape[0]):
            objects_merged.loc[index, column_name] = row[look_for_area_column] / row[area_column]

    # transfer data from merged df to original df
    print('Merging data...')
    objects[column_name] = objects_merged[column_name]

    print('Floor area ratio calculated.')
    return objects

# objects.to_file("/Users/martin/Strathcloud/Personal Folders/Test data/Prague/p7_voro_single4.shp")
#
# objects = gpd.read_file("/Users/martin/Strathcloud/Personal Folders/Test data/Prague/p7_voro_single.shp")
# column_name = 'test'
# objects
# objects2.head
# objects['geometry'] = objects.centroid
# objects_centroids
